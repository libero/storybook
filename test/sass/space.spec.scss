@use "test" as *;
@use "../../src/shared-styles/space";

/* stylelint-disable csstools/use-logical  */

@include describe("@mixin padding") {

  @include it("generates correct rule from a single zero value and no dimension") {

    @include assert() {

      @include output {
        @include space.padding(0);
      }

      @include expect {
        padding: 0;
      }

    }

  }

  @include it("generates correct rule from a single non-zero value and no dimension") {

    @include assert() {

      @include output {
        @include space.padding(16px);
      }

      @include expect {
        padding: 1rem;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1em);
      }

      @include expect {
        padding: 1em;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1rem);
      }

      @include expect {
        padding: 1rem;
      }

    }

  }

  @include it("generates correct rule from a pair of non-zero values and no dimension") {

    @include assert() {

      @include output {
        @include space.padding(32px 32px);
      }

      @include expect {
        padding: 2rem;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(32px 48px);
      }

      @include expect {
        padding: 2rem 3rem;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(2em 3em);
      }

      @include expect {
        padding: 2em 3em;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(2rem 3rem);
      }

      @include expect {
        padding: 2rem 3rem;
      }

    }

  }

  @include it("generates correct rule from three non-zero values and no dimension") {

    @include assert() {

      @include output {
        @include space.padding(32px 32px 32px);
      }

      @include expect {
        padding: 2rem;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(32px 48px 32px);
      }

      @include expect {
        padding: 2rem 3rem;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(32px 48px 64px);
      }

      @include expect {
        padding: 2rem 3rem 4rem;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(2em 3em 4em);
      }

      @include expect {
        padding: 2em 3em 4em;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(2rem 3rem 4rem);
      }

      @include expect {
        padding: 2rem 3rem 4rem;
      }

    }

  }

  @include it("generates correct rule from one zero and one non-zero value and no dimension") {

    @include assert() {

      @include output {
        @include space.padding(0 48px);
      }

      @include expect {
        padding: 0 3rem;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(48px 0);
      }

      @include expect {
        padding: 3rem 0;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(0 3em);
      }

      @include expect {
        padding: 0 3em;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(0 3rem);
      }

      @include expect {
        padding: 0 3rem;
      }

    }

  }

  @include it("generates correct rule from in total three zero and/or non-zero values and no dimension") {

    @include assert() {

      @include output {
        @include space.padding(0 48px 128px);
      }

      @include expect {
        padding: 0 3rem 8rem;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(48px 0 128px);
      }

      @include expect {
        padding: 3rem 0 8rem;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(48px 128px 0);
      }

      @include expect {
        padding: 3rem 8rem 0;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(3em 0 8em);
      }

      @include expect {
        padding: 3em 0 8em;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(3rem 0 8rem);
      }

      @include expect {
        padding: 3rem 0 8rem;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(0 0 0);
      }

      @include expect {
        padding: 0;
      }

    }

  }

  @include it("generates correct rules from in total four zero and/or non-zero values and no dimension") {

    @include assert() {

      @include output {
        @include space.padding(0 48px 128px 256px);
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding: 0 3rem 8rem 16rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding: 0 16rem 8rem 3rem;
        }
        html[dir][dir] & {
          padding-block-start: 0;
          padding-block-end: 8rem;
          padding-inline-start: 16rem;
          padding-inline-end: 3rem;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.padding(0 3em 8em 16em);
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding: 0 3em 8em 16em;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding: 0 16em 8em 3em;
        }
        html[dir][dir] & {
          padding-block-start: 0;
          padding-block-end: 8em;
          padding-inline-start: 16em;
          padding-inline-end: 3em;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.padding(0 3rem 8rem 16rem);
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding: 0 3rem 8rem 16rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding: 0 16rem 8rem 3rem;
        }
        html[dir][dir] & {
          padding-block-start: 0;
          padding-block-end: 8rem;
          padding-inline-start: 16rem;
          padding-inline-end: 3rem;
        }
      }
    }

    @include assert() {

      @include output {
        @include space.padding(0 0 0 0);
      }

      @include expect {
        padding: 0;
      }

    }

  }

  @include it("errors when 5 sizes values passed and no dimension") {

    @include assert() {

      @include output {
        @include space.padding(1 2 3 4 5);
      }

      @include expect {
        _error: "More than four sizes supplied when no dimension";
      }

    }

  }

  @include it("generates correct rules with a single zero value for dimension 'inline'") {

    @include assert() {

      @include output {
        @include space.padding(0, "inline");
      }

      @include expect {
        padding-left: 0;
        padding-right: 0;
        padding-inline: 0;
      }

    }

  }

  @include it("generates correct rules from a single non-zero value for dimension 'inline'") {

    @include assert() {

      @include output {
        @include space.padding(16px, "inline");
      }

      @include expect {
        padding-left: 1rem;
        padding-right: 1rem;
        padding-inline: 1rem;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1em, "inline");
      }

      @include expect {
        padding-left: 1em;
        padding-right: 1em;
        padding-inline: 1em;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1rem, "inline");
      }

      @include expect {
        padding-left: 1rem;
        padding-right: 1rem;
        padding-inline: 1rem;
      }

    }

  }

  @include it("generates correct rules from a pair of values for dimension 'inline'") {

    @include assert() {

      @include output {
        @include space.padding(16px 32px, "inline");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding-left: 1rem;
          padding-right: 2rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding-right: 1rem;
          padding-left: 2rem;
        }

        html[dir][dir] & {
          padding-inline-start: 1rem;
          padding-inline-end: 2rem;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1em 2em, "inline");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding-left: 1em;
          padding-right: 2em;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding-right: 1em;
          padding-left: 2em;
        }

        html[dir][dir] & {
          padding-inline-start: 1em;
          padding-inline-end: 2em;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1rem 2rem, "inline");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding-left: 1rem;
          padding-right: 2rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding-right: 1rem;
          padding-left: 2rem;
        }

        html[dir][dir] & {
          padding-inline-start: 1rem;
          padding-inline-end: 2rem;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.padding(16px 16px, "inline");
      }

      @include expect {
        padding-left: 1rem;
        padding-right: 1rem;
        padding-inline: 1rem;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(0 32px, "inline");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding-left: 0;
          padding-right: 2rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding-right: 0;
          padding-left: 2rem;
        }

        html[dir][dir] & {
          padding-inline-start: 0;
          padding-inline-end: 2rem;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.padding(16px 0, "inline");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding-left: 1rem;
          padding-right: 0;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding-right: 1rem;
          padding-left: 0;
        }

        html[dir][dir] & {
          padding-inline-start: 1rem;
          padding-inline-end: 0;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.padding(0 0, "inline");
      }

      @include expect {
        padding-left: 0;
        padding-right: 0;
        padding-inline: 0;
      }

    }

  }

  @include it("errors when 3 size values passed with dimension 'inline'") {

    @include assert() {

      @include output {
        @include space.padding(1 2 3, "inline");
      }

      @include expect {
        _error: "More than two sizes supplied with 'inline' dimension";
      }

    }

  }

  @include it("generates correct rules from a single zero value for the dimension 'inline-start'") {

    @include assert() {

      @include output {
        @include space.padding(0, "inline-start");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding-left: 0;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding-right: 0;
        }
        html[dir][dir] & {
          padding-inline-start: 0;
        }

      }

    }

  }

  @include it("generates correct rules from a single non-zero value for the dimension 'inline-start'") {

    @include assert() {

      @include output {
        @include space.padding(16px, "inline-start");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding-left: 1rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding-right: 1rem;
        }
        html[dir][dir] & {
          padding-inline-start: 1rem;
        }
      }
    }

    @include assert() {

      @include output {
        @include space.padding(1em, "inline-start");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding-left: 1em;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding-right: 1em;
        }
        html[dir][dir] & {
          padding-inline-start: 1em;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1rem, "inline-start");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding-left: 1rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding-right: 1rem;
        }
        html[dir][dir] & {
          padding-inline-start: 1rem;
        }
      }

    }

  }

  @include it("errors when 2 size values passed with dimension 'inline-start'") {

    @include assert() {

      @include output {
        @include space.padding(1 2, "inline-start");
      }

      @include expect {
        _error: "More than one size supplied with 'inline-start' dimension";
      }

    }

  }

  @include it("generates correct rules from a single zero value for the dimension 'inline-end'") {

    @include assert() {

      @include output {
        @include space.padding(0, "inline-end");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding-right: 0;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding-left: 0;
        }
        html[dir][dir] & {
          padding-inline-end: 0;
        }

      }

    }

  }

  @include it("generates correct rules from a single non-zero value for the dimension 'inline-end'") {

    @include assert() {

      @include output {
        @include space.padding(16px, "inline-end");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding-right: 1rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding-left: 1rem;
        }
        html[dir][dir] & {
          padding-inline-end: 1rem;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1em, "inline-end");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding-right: 1em;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding-left: 1em;
        }
        html[dir][dir] & {
          padding-inline-end: 1em;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1rem, "inline-end");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding-right: 1rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding-left: 1rem;
        }
        html[dir][dir] & {
          padding-inline-end: 1rem;
        }
      }

    }

  }

  @include it("errors when 2 size values passed with dimension 'inline-end'") {

    @include assert() {

      @include output {
        @include space.padding(1 2, "inline-end");
      }

      @include expect {
        _error: "More than one size supplied with 'inline-end' dimension";
      }

    }

  }

  @include it("generates correct rules from a single zero value for dimension 'block'") {

    @include assert() {

      @include output {
        @include space.padding(0, "block");
      }

      @include expect {
        padding-top: 0;
        padding-bottom: 0;
        padding-block: 0;
      }

    }

  }

  @include it("generates correct rules from a single non-zero value for dimension 'block'") {

    @include assert() {

      @include output {
        @include space.padding(16px, "block");
      }

      @include expect {
        padding-top: 1rem;
        padding-bottom: 1rem;
        padding-block: 1rem;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1em, "block");
      }

      @include expect {
        padding-top: 1em;
        padding-bottom: 1em;
        padding-block: 1em;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1rem, "block");
      }

      @include expect {
        padding-top: 1rem;
        padding-bottom: 1rem;
        padding-block: 1rem;
      }

    }

  }

  // Vertical writing modes not yet supported
  @include it("generates correct rules from a pair of non-zero values for dimension 'block'") {

    @include assert() {

      @include output {
        @include space.padding(16px 32px, "block");
      }

      @include expect {
        padding-top: 1rem;
        padding-bottom: 2rem;
        padding-block-start: 1rem;
        padding-block-end: 2rem;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1em 2em, "block");
      }

      @include expect {
        padding-top: 1em;
        padding-bottom: 2em;
        padding-block-start: 1em;
        padding-block-end: 2em;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1rem 2rem, "block");
      }

      @include expect {
        padding-top: 1rem;
        padding-bottom: 2rem;
        padding-block-start: 1rem;
        padding-block-end: 2rem;
      }

    }

  }

  @include it("errors when 3 size values passed with dimension 'block'") {

    @include assert() {

      @include output {
        @include space.padding(1 2 3, "block");
      }

      @include expect {
        _error: "More than two sizes supplied with 'block' dimension";
      }

    }

  }

  @include it("generates correct rules from a single zero value and dimension 'block-start'") {

    @include assert() {

      @include output {
        @include space.padding(0, "block-start");
      }

      @include expect {
        padding-top: 0;
        padding-block-start: 0;
      }

    }

  }

  @include it("generates correct rules from a single non-zero value and dimension 'block-start'") {

    @include assert() {

      @include output {
        @include space.padding(16px, "block-start");
      }

      @include expect {
        padding-top: 1rem;
        padding-block-start: 1rem;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1em, "block-start");
      }

      @include expect {
        padding-top: 1em;
        padding-block-start: 1em;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1rem, "block-start");
      }

      @include expect {
        padding-top: 1rem;
        padding-block-start: 1rem;
      }

    }

  }

  @include it("errors when 2 size values passed with dimension 'block-start'") {

    @include assert() {

      @include output {
        @include space.padding(1 2, "block-start");
      }

      @include expect {
        _error: "More than one size supplied with 'block-start' dimension";
      }

    }

  }

  @include it("generates correct rules from a single zero value and dimension 'block-end'") {

    @include assert() {

      @include output {
        @include space.padding(0, "block-end");
      }

      @include expect {
        padding-bottom: 0;
        padding-block-end: 0;
      }

    }

  }

  @include it("generates correct rules from a single non-zero value and dimension 'block-end'") {

    @include assert() {

      @include output {
        @include space.padding(16px, "block-end");
      }

      @include expect {
        padding-bottom: 1rem;
        padding-block-end: 1rem;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1em, "block-end");
      }

      @include expect {
        padding-bottom: 1em;
        padding-block-end: 1em;
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1rem, "block-end");
      }

      @include expect {
        padding-bottom: 1rem;
        padding-block-end: 1rem;
      }

    }

  }

  @include it("errors when 2 size values passed with dimension 'block-end'") {

    @include assert() {

      @include output {
        @include space.padding(1 2, "block-end");
      }

      @include expect {
        _error: "More than one size supplied with 'block-end' dimension";
      }

    }

  }

  @include it("errors on invalid dimensions") {

    @include assert() {

      @include output {
        @include space.padding(1, "top");
      }

      @include expect {
        _error: "'top' is a physical dimension, use its logical equivilant";
      }

    }

    @include assert() {

      @include output {
        @include space.padding(1, "foo");
      }

      @include expect {
        _error: "Unknown dimension 'foo'";
      }

    }

  }

}

@include describe("@mixin margin") {

  @include it("generates correct rule from a single zero value and no dimension") {

    @include assert() {

      @include output {
        @include space.margin(0);
      }

      @include expect {
        margin: 0;
      }

    }

  }

  @include it("generates correct rule from a single non-zero value and no dimension") {

    @include assert() {

      @include output {
        @include space.margin(16px);
      }

      @include expect {
        margin: 1rem;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1em);
      }

      @include expect {
        margin: 1em;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1rem);
      }

      @include expect {
        margin: 1rem;
      }

    }

  }

  @include it("generates correct rule from a pair of non-zero values and no dimension") {

    @include assert() {

      @include output {
        @include space.margin(32px 32px);
      }

      @include expect {
        margin: 2rem;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(32px 48px);
      }

      @include expect {
        margin: 2rem 3rem;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(2em 3em);
      }

      @include expect {
        margin: 2em 3em;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(2rem 3rem);
      }

      @include expect {
        margin: 2rem 3rem;
      }

    }

  }

  @include it("generates correct rule from three non-zero values and no dimension") {

    @include assert() {

      @include output {
        @include space.margin(32px 32px 32px);
      }

      @include expect {
        margin: 2rem;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(32px 48px 32px);
      }

      @include expect {
        margin: 2rem 3rem;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(32px 48px 64px);
      }

      @include expect {
        margin: 2rem 3rem 4rem;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(2em 3em 4em);
      }

      @include expect {
        margin: 2em 3em 4em;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(2rem 3rem 4rem);
      }

      @include expect {
        margin: 2rem 3rem 4rem;
      }

    }

  }

  @include it("generates correct rule from one zero and one non-zero value and no dimension") {

    @include assert() {

      @include output {
        @include space.margin(0 48px);
      }

      @include expect {
        margin: 0 3rem;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(48px 0);
      }

      @include expect {
        margin: 3rem 0;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(0 3em);
      }

      @include expect {
        margin: 0 3em;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(0 3rem);
      }

      @include expect {
        margin: 0 3rem;
      }

    }

  }

  @include it("generates correct rule from in total three zero and/or non-zero values and no dimension") {

    @include assert() {

      @include output {
        @include space.margin(0 48px 128px);
      }

      @include expect {
        margin: 0 3rem 8rem;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(48px 0 128px);
      }

      @include expect {
        margin: 3rem 0 8rem;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(48px 128px 0);
      }

      @include expect {
        margin: 3rem 8rem 0;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(3em 0 8em);
      }

      @include expect {
        margin: 3em 0 8em;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(3rem 0 8rem);
      }

      @include expect {
        margin: 3rem 0 8rem;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(0 0 0);
      }

      @include expect {
        margin: 0;
      }

    }

  }

  @include it("generates correct rules from in total four zero and/or non-zero values and no dimension") {

    @include assert() {

      @include output {
        @include space.margin(0 48px 128px 256px);
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin: 0 3rem 8rem 16rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin: 0 16rem 8rem 3rem;
        }
        html[dir][dir] & {
          margin-block-start: 0;
          margin-block-end: 8rem;
          margin-inline-start: 16rem;
          margin-inline-end: 3rem;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.margin(0 3em 8em 16em);
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin: 0 3em 8em 16em;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin: 0 16em 8em 3em;
        }
        html[dir][dir] & {
          margin-block-start: 0;
          margin-block-end: 8em;
          margin-inline-start: 16em;
          margin-inline-end: 3em;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.margin(0 3rem 8rem 16rem);
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin: 0 3rem 8rem 16rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin: 0 16rem 8rem 3rem;
        }
        html[dir][dir] & {
          margin-block-start: 0;
          margin-block-end: 8rem;
          margin-inline-start: 16rem;
          margin-inline-end: 3rem;
        }
      }
    }

    @include assert() {

      @include output {
        @include space.margin(0 0 0 0);
      }

      @include expect {
        margin: 0;
      }

    }

  }

  @include it("errors when 5 sizes values passed and no dimension") {

    @include assert() {

      @include output {
        @include space.margin(1 2 3 4 5);
      }

      @include expect {
        _error: "More than four sizes supplied when no dimension";
      }

    }

  }

  @include it("generates correct rules from a single zero value for dimension 'inline'") {

    @include assert() {

      @include output {
        @include space.margin(0, "inline");
      }

      @include expect {
        margin-left: 0;
        margin-right: 0;
        margin-inline: 0;
      }

    }

  }

  @include it("generates correct rules from a single non-zero value for dimension 'inline'") {

    @include assert() {

      @include output {
        @include space.margin(16px, "inline");
      }

      @include expect {
        margin-left: 1rem;
        margin-right: 1rem;
        margin-inline: 1rem;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1em, "inline");
      }

      @include expect {
        margin-left: 1em;
        margin-right: 1em;
        margin-inline: 1em;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1rem, "inline");
      }

      @include expect {
        margin-left: 1rem;
        margin-right: 1rem;
        margin-inline: 1rem;
      }

    }

  }

  @include it("generates correct rules from a pair of values for dimension 'inline'") {

    @include assert() {

      @include output {
        @include space.margin(16px 32px, "inline");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin-left: 1rem;
          margin-right: 2rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin-right: 1rem;
          margin-left: 2rem;
        }

        html[dir][dir] & {
          margin-inline-start: 1rem;
          margin-inline-end: 2rem;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1em 2em, "inline");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin-left: 1em;
          margin-right: 2em;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin-right: 1em;
          margin-left: 2em;
        }

        html[dir][dir] & {
          margin-inline-start: 1em;
          margin-inline-end: 2em;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1rem 2rem, "inline");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin-left: 1rem;
          margin-right: 2rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin-right: 1rem;
          margin-left: 2rem;
        }

        html[dir][dir] & {
          margin-inline-start: 1rem;
          margin-inline-end: 2rem;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.margin(16px 16px, "inline");
      }

      @include expect {
        margin-left: 1rem;
        margin-right: 1rem;
        margin-inline: 1rem;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(0 32px, "inline");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin-left: 0;
          margin-right: 2rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin-right: 0;
          margin-left: 2rem;
        }

        html[dir][dir] & {
          margin-inline-start: 0;
          margin-inline-end: 2rem;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.margin(16px 0, "inline");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin-left: 1rem;
          margin-right: 0;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin-right: 1rem;
          margin-left: 0;
        }

        html[dir][dir] & {
          margin-inline-start: 1rem;
          margin-inline-end: 0;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.margin(0 0, "inline");
      }

      @include expect {
        margin-left: 0;
        margin-right: 0;
        margin-inline: 0;
      }

    }

  }

  @include it("errors when 3 sizes values passed with dimension 'inline'") {

    @include assert() {

      @include output {
        @include space.margin(1 2 3, "inline");
      }

      @include expect {
        _error: "More than two sizes supplied with 'inline' dimension";
      }

    }

  }

  @include it("generates correct rules from a single zero value for the dimension 'inline-start'") {

    @include assert() {

      @include output {
        @include space.margin(0, "inline-start");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin-left: 0;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin-right: 0;
        }
        html[dir][dir] & {
          margin-inline-start: 0;
        }

      }

    }

  }

  @include it("generates correct rules from a single non-zero value for the dimension 'inline-start'") {

    @include assert() {

      @include output {
        @include space.margin(16px, "inline-start");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin-left: 1rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin-right: 1rem;
        }
        html[dir][dir] & {
          margin-inline-start: 1rem;
        }
      }
    }

    @include assert() {

      @include output {
        @include space.margin(1em, "inline-start");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin-left: 1em;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin-right: 1em;
        }
        html[dir][dir] & {
          margin-inline-start: 1em;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1rem, "inline-start");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin-left: 1rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin-right: 1rem;
        }
        html[dir][dir] & {
          margin-inline-start: 1rem;
        }
      }

    }

  }

  @include it("errors when 2 sizes values passed with dimension 'inline-start'") {

    @include assert() {

      @include output {
        @include space.margin(1 2, "inline-start");
      }

      @include expect {
        _error: "More than one size supplied with 'inline-start' dimension";
      }

    }

  }

  @include it("generates correct rules from a single zero value for the dimension 'inline-end'") {

    @include assert() {

      @include output {
        @include space.margin(0, "inline-end");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin-right: 0;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin-left: 0;
        }
        html[dir][dir] & {
          margin-inline-end: 0;
        }

      }

    }

  }

  @include it("generates correct rules from a single non-zero value for the dimension 'inline-end'") {

    @include assert() {

      @include output {
        @include space.margin(16px, "inline-end");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin-right: 1rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin-left: 1rem;
        }
        html[dir][dir] & {
          margin-inline-end: 1rem;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1em, "inline-end");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin-right: 1em;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin-left: 1em;
        }
        html[dir][dir] & {
          margin-inline-end: 1em;
        }
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1rem, "inline-end");
      }

      @include expect {
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin-right: 1rem;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin-left: 1rem;
        }
        html[dir][dir] & {
          margin-inline-end: 1rem;
        }
      }

    }

  }

  @include it("errors when 2 sizes values passed with dimension 'inline-end'") {

    @include assert() {

      @include output {
        @include space.margin(1 2, "inline-end");
      }

      @include expect {
        _error: "More than one size supplied with 'inline-end' dimension";
      }

    }

  }

  @include it("generates correct rules from a single zero value for dimension 'block'") {

    @include assert() {

      @include output {
        @include space.margin(0, "block");
      }

      @include expect {
        margin-top: 0;
        margin-bottom: 0;
        margin-block: 0;
      }

    }

  }

  @include it("generates correct rules from a single non-zero value for dimension 'block'") {

    @include assert() {

      @include output {
        @include space.margin(16px, "block");
      }

      @include expect {
        margin-top: 1rem;
        margin-bottom: 1rem;
        margin-block: 1rem;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1em, "block");
      }

      @include expect {
        margin-top: 1em;
        margin-bottom: 1em;
        margin-block: 1em;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1rem, "block");
      }

      @include expect {
        margin-top: 1rem;
        margin-bottom: 1rem;
        margin-block: 1rem;
      }

    }

  }

  // Vertical writing modes not yet supported
  @include it("generates correct rules from a pair of non-zero values for dimension 'block'") {

    @include assert() {

      @include output {
        @include space.margin(16px 32px, "block");
      }

      @include expect {
        margin-top: 1rem;
        margin-bottom: 2rem;
        margin-block-start: 1rem;
        margin-block-end: 2rem;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1em 2em, "block");
      }

      @include expect {
        margin-top: 1em;
        margin-bottom: 2em;
        margin-block-start: 1em;
        margin-block-end: 2em;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1rem 2rem, "block");
      }

      @include expect {
        margin-top: 1rem;
        margin-bottom: 2rem;
        margin-block-start: 1rem;
        margin-block-end: 2rem;
      }

    }

  }

  @include it("errors when 3 sizes values passed with dimension 'block'") {

    @include assert() {

      @include output {
        @include space.margin(1 2 3, "block");
      }

      @include expect {
        _error: "More than two sizes supplied with 'block' dimension";
      }

    }

  }

  @include it("generates correct rules from a single zero value and dimension 'block-start'") {

    @include assert() {

      @include output {
        @include space.margin(0, "block-start");
      }

      @include expect {
        margin-top: 0;
        margin-block-start: 0;
      }

    }

  }

  @include it("generates correct rules from a single non-zero value and dimension 'block-start'") {

    @include assert() {

      @include output {
        @include space.margin(16px, "block-start");
      }

      @include expect {
        margin-top: 1rem;
        margin-block-start: 1rem;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1em, "block-start");
      }

      @include expect {
        margin-top: 1em;
        margin-block-start: 1em;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1rem, "block-start");
      }

      @include expect {
        margin-top: 1rem;
        margin-block-start: 1rem;
      }

    }

  }

  @include it("errors when 2 sizes values passed with dimension 'block-start'") {

    @include assert() {

      @include output {
        @include space.margin(1 2, "block-start");
      }

      @include expect {
        _error: "More than one size supplied with 'block-start' dimension";
      }

    }

  }

  @include it("generates correct rules from a single zero value and dimension 'block-end'") {

    @include assert() {

      @include output {
        @include space.margin(0, "block-end");
      }

      @include expect {
        margin-bottom: 0;
        margin-block-end: 0;
      }

    }

  }

  @include it("generates correct rules from a single non-zero value and dimension 'block-end'") {

    @include assert() {

      @include output {
        @include space.margin(16px, "block-end");
      }

      @include expect {
        margin-bottom: 1rem;
        margin-block-end: 1rem;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1em, "block-end");
      }

      @include expect {
        margin-bottom: 1em;
        margin-block-end: 1em;
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1rem, "block-end");
      }

      @include expect {
        margin-bottom: 1rem;
        margin-block-end: 1rem;
      }

    }

  }

  @include it("errors when 2 sizes values passed with dimension 'block-end'") {

    @include assert() {

      @include output {
        @include space.margin(1 2, "block-end");
      }

      @include expect {
        _error: "More than one size supplied with 'block-end' dimension";
      }

    }

  }

  @include it("errors on invalid dimensions") {

    @include assert() {

      @include output {
        @include space.margin(1, "top");
      }

      @include expect {
        _error: "'top' is a physical dimension, use its logical equivilant";
      }

    }

    @include assert() {

      @include output {
        @include space.margin(1, "foo");
      }

      @include expect {
        _error: "Unknown dimension 'foo'";
      }

    }

  }

}

@include describe("@mixin block") {

  @include it("by default sets a margin of block-start 0 and block end of 4 baseline units, with fallback") {

    @include assert() {

      @include output {
        @include space.block();
      }

      @include expect() {
        margin-top: 0;
        margin-bottom: 1.5rem;
        margin-block-start: 0;
        margin-block-end: 1.5rem;
      }

    }

  }

  @include it("allows block-start and block-end to be independently configured") {

    @include assert() {

      @include output {
        @include space.block(16px, 32px);
      }

      @include expect() {
        margin-top: 1rem;
        margin-bottom: 2rem;
        margin-block-start: 1rem;
        margin-block-end: 2rem;
      }

    }

  }

}

@include describe("@mixin nospace") {

  @include it("generates correct zeroing for the dimension 'inline'") {

    @include assert() {

      @include output {
        @include space.none("inline");
      }

      @include expect {
        margin-left: 0;
        margin-right: 0;
        margin-inline: 0;
        padding-left: 0;
        padding-right: 0;
        padding-inline: 0;

      }

    }

  }

  @include it("generates correct zeroing for the dimension 'inline-start'") {

    @include assert {

      @include output {
        @include space.none("inline-start");
      }

      @include expect {

        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin-left: 0;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin-right: 0;
        }
        html[dir][dir] & {
          margin-inline-start: 0;
        }
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding-left: 0;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding-right: 0;
        }
        html[dir][dir] & {
          padding-inline-start: 0;
        }
      }

    }

  }

  @include it("generates correct zeroing for the dimension 'inline-end'") {

    @include assert {

      @include output {
        @include space.none("inline-end");
      }

      @include expect {

        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          margin-right: 0;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          margin-left: 0;
        }
        html[dir][dir] & {
          margin-inline-end: 0;
        }
        html[dir="ltr"] &:not([dir]),
        &[dir="ltr"] {
          padding-right: 0;
        }
        html[dir="rtl"] &:not([dir]),
        &[dir="rtl"] {
          padding-left: 0;
        }
        html[dir][dir] & {
          padding-inline-end: 0;
        }
      }

    }

  }

  @include it("generates correct zeroing for the dimension 'block'") {

    @include assert() {

      @include output {
        @include space.none("block");
      }

      @include expect {
        margin-top: 0;
        margin-bottom: 0;
        margin-block: 0;
        padding-top: 0;
        padding-bottom: 0;
        padding-block: 0;
      }

    }

  }

  // vertical writing modes not supported, so block-start always maps to top at the moment.
  @include it("generates correct zeroing for the dimension 'block-start'") {

    @include assert() {

      @include output {
        @include space.none("block-start");
      }

      @include expect {
        margin-top: 0;
        margin-block-start: 0;
        padding-top: 0;
        padding-block-start: 0;
      }

    }

  }

  @include it("generates correct zeroing for the dimension 'block-end'") {

    @include assert() {

      @include output {
        @include space.none("block-end");
      }

      @include expect {
        margin-bottom: 0;
        margin-block-end: 0;
        padding-bottom: 0;
        padding-block-end: 0;
      }

    }

  }

  @include it("generates correct zeroing for all dimensions when not supplied with any dimension") {

    @include assert() {

      @include output {
        @include space.none();
      }

      @include expect {
        margin: 0;
        padding: 0;
      }

    }

  }

  @include it("errors on invalid dimensions") {

    @include assert() {

      @include output {
        @include space.none("top");
      }

      @include contains {
        _error: "'top' is a physical dimension, use its logical equivilant";
      }

    }

    @include assert() {

      @include output {
        @include space.none("foo");
      }

      @include contains {
        _error: "Unknown dimension 'foo'";
      }

    }

  }

}
